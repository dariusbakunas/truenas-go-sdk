/*
 * TrueNAS RESTful API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v2.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package truenas

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// PoolDatasetApiService PoolDatasetApi service
type PoolDatasetApiService service

type ApiPoolDatasetChangeKeyPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	poolDatasetChangeKey *PoolDatasetChangeKey
}

func (r ApiPoolDatasetChangeKeyPostRequest) PoolDatasetChangeKey(poolDatasetChangeKey PoolDatasetChangeKey) ApiPoolDatasetChangeKeyPostRequest {
	r.poolDatasetChangeKey = &poolDatasetChangeKey
	return r
}

func (r ApiPoolDatasetChangeKeyPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetChangeKeyPostExecute(r)
}

/*
 * PoolDatasetChangeKeyPost Method for PoolDatasetChangeKeyPost
 * Change encryption properties for `id` encrypted dataset.

Changing dataset encryption to use passphrase instead of a key is not allowed if:

1) It has encrypted roots as children which are encrypted with a key
2) If it is a root dataset where the system dataset is located

A file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetChangeKeyPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetChangeKeyPost(ctx _context.Context) ApiPoolDatasetChangeKeyPostRequest {
	return ApiPoolDatasetChangeKeyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetChangeKeyPostExecute(r ApiPoolDatasetChangeKeyPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetChangeKeyPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/change_key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetChangeKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetCompressionChoicesGetRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
}


func (r ApiPoolDatasetCompressionChoicesGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetCompressionChoicesGetExecute(r)
}

/*
 * PoolDatasetCompressionChoicesGet Method for PoolDatasetCompressionChoicesGet
 * Retrieve compression algorithm supported by ZFS.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetCompressionChoicesGetRequest
 */
func (a *PoolDatasetApiService) PoolDatasetCompressionChoicesGet(ctx _context.Context) ApiPoolDatasetCompressionChoicesGetRequest {
	return ApiPoolDatasetCompressionChoicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetCompressionChoicesGetExecute(r ApiPoolDatasetCompressionChoicesGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetCompressionChoicesGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/compression_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
}


func (r ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetEncryptionAlgorithmChoicesGetExecute(r)
}

/*
 * PoolDatasetEncryptionAlgorithmChoicesGet Method for PoolDatasetEncryptionAlgorithmChoicesGet
 * Retrieve encryption algorithms supported for ZFS dataset encryption.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest
 */
func (a *PoolDatasetApiService) PoolDatasetEncryptionAlgorithmChoicesGet(ctx _context.Context) ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest {
	return ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetEncryptionAlgorithmChoicesGetExecute(r ApiPoolDatasetEncryptionAlgorithmChoicesGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetEncryptionAlgorithmChoicesGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/encryption_algorithm_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetEncryptionSummaryPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	poolDatasetEncryptionSummary *PoolDatasetEncryptionSummary
}

func (r ApiPoolDatasetEncryptionSummaryPostRequest) PoolDatasetEncryptionSummary(poolDatasetEncryptionSummary PoolDatasetEncryptionSummary) ApiPoolDatasetEncryptionSummaryPostRequest {
	r.poolDatasetEncryptionSummary = &poolDatasetEncryptionSummary
	return r
}

func (r ApiPoolDatasetEncryptionSummaryPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetEncryptionSummaryPostExecute(r)
}

/*
 * PoolDatasetEncryptionSummaryPost Method for PoolDatasetEncryptionSummaryPost
 * Retrieve summary of all encrypted roots under `id`.

Keys/passphrase can be supplied to check if the keys are valid.

It should be noted that there are 2 keys which show if a recursive unlock operation is
done for `id`, which dataset will be unlocked and if not why it won't be unlocked. The keys
namely are "unlock_successful" and "unlock_error". The former is a boolean value showing if unlock
would succeed/fail. The latter is description why it failed if it failed.

If a dataset is already unlocked, it will show up as true for "unlock_successful" regardless of what
key user provided as the unlock keys in the output are to reflect what a real unlock operation would
behave. If user is interested in seeing if a provided key is valid or not, then the key to look out for
in the output is "valid_key" which based on what system has in database or if a user provided one, validates
the key and sets a boolean value for the dataset.

Example output:
[
    {
        "name": "vol",
        "key_format": "PASSPHRASE",
        "key_present_in_database": false,
        "valid_key": true,
        "locked": true,
        "unlock_error": null,
        "unlock_successful": true
    },
    {
        "name": "vol/c1/d1",
        "key_format": "PASSPHRASE",
        "key_present_in_database": false,
        "valid_key": false,
        "locked": true,
        "unlock_error": "Provided key is invalid",
        "unlock_successful": false
    },
    {
        "name": "vol/c",
        "key_format": "PASSPHRASE",
        "key_present_in_database": false,
        "valid_key": false,
        "locked": true,
        "unlock_error": "Key not provided",
        "unlock_successful": false
    },
    {
        "name": "vol/c/d2",
        "key_format": "PASSPHRASE",
        "key_present_in_database": false,
        "valid_key": false,
        "locked": true,
        "unlock_error": "Child cannot be unlocked when parent "vol/c" is locked and provided key is invalid",
        "unlock_successful": false
    }
]

A file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetEncryptionSummaryPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetEncryptionSummaryPost(ctx _context.Context) ApiPoolDatasetEncryptionSummaryPostRequest {
	return ApiPoolDatasetEncryptionSummaryPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetEncryptionSummaryPostExecute(r ApiPoolDatasetEncryptionSummaryPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetEncryptionSummaryPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/encryption_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetEncryptionSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetExportKeyPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	poolDatasetExportKey *PoolDatasetExportKey
}

func (r ApiPoolDatasetExportKeyPostRequest) PoolDatasetExportKey(poolDatasetExportKey PoolDatasetExportKey) ApiPoolDatasetExportKeyPostRequest {
	r.poolDatasetExportKey = &poolDatasetExportKey
	return r
}

func (r ApiPoolDatasetExportKeyPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetExportKeyPostExecute(r)
}

/*
 * PoolDatasetExportKeyPost Method for PoolDatasetExportKeyPost
 * Export own encryption key for dataset `id`. If `download` is `true`, key will be downloaded as a text file,
otherwise it will be returned as string.

Please refer to websocket documentation for downloading the file.

A file can be downloaded from this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetExportKeyPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetExportKeyPost(ctx _context.Context) ApiPoolDatasetExportKeyPostRequest {
	return ApiPoolDatasetExportKeyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetExportKeyPostExecute(r ApiPoolDatasetExportKeyPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetExportKeyPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/export_key"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetExportKey
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetGetRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	limit *int32
	offset *int32
	count *bool
	sort *string
}

func (r ApiPoolDatasetGetRequest) Limit(limit int32) ApiPoolDatasetGetRequest {
	r.limit = &limit
	return r
}
func (r ApiPoolDatasetGetRequest) Offset(offset int32) ApiPoolDatasetGetRequest {
	r.offset = &offset
	return r
}
func (r ApiPoolDatasetGetRequest) Count(count bool) ApiPoolDatasetGetRequest {
	r.count = &count
	return r
}
func (r ApiPoolDatasetGetRequest) Sort(sort string) ApiPoolDatasetGetRequest {
	r.sort = &sort
	return r
}

func (r ApiPoolDatasetGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetGetExecute(r)
}

/*
 * PoolDatasetGet Method for PoolDatasetGet
 * Query Pool Datasets with `query-filters` and `query-options`.

We provide two ways to retrieve datasets. The first is a flat structure (default), where
all datasets in the system are returned as separate objects which contain all data
there is for their children. This retrieval type is slightly slower because of duplicates in each object.
The second type is hierarchical, where only top level datasets are returned in the list. They contain all the
children in the `children` key. This retrieval type is slightly faster.
These options are controlled by the `query-options.extra.flat` attribute (default true).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetGetRequest
 */
func (a *PoolDatasetApiService) PoolDatasetGet(ctx _context.Context) ApiPoolDatasetGetRequest {
	return ApiPoolDatasetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetGetExecute(r ApiPoolDatasetGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdAttachmentsPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	body *map[string]interface{}
}

func (r ApiPoolDatasetIdIdAttachmentsPostRequest) Body(body map[string]interface{}) ApiPoolDatasetIdIdAttachmentsPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetIdIdAttachmentsPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdAttachmentsPostExecute(r)
}

/*
 * PoolDatasetIdIdAttachmentsPost Method for PoolDatasetIdIdAttachmentsPost
 * Return a list of services dependent of this dataset.

Responsible for telling the user whether there is a related
share, asking for confirmation.

Example return value:
[
  {
    "type": "NFS Share",
    "service": "nfs",
    "attachments": ["/mnt/tank/work"]
  }
]
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdAttachmentsPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdAttachmentsPost(ctx _context.Context, id string) ApiPoolDatasetIdIdAttachmentsPostRequest {
	return ApiPoolDatasetIdIdAttachmentsPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdAttachmentsPostExecute(r ApiPoolDatasetIdIdAttachmentsPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdAttachmentsPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/attachments"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdDeleteRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	poolDatasetDelete1 *PoolDatasetDelete1
}

func (r ApiPoolDatasetIdIdDeleteRequest) PoolDatasetDelete1(poolDatasetDelete1 PoolDatasetDelete1) ApiPoolDatasetIdIdDeleteRequest {
	r.poolDatasetDelete1 = &poolDatasetDelete1
	return r
}

func (r ApiPoolDatasetIdIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdDeleteExecute(r)
}

/*
 * PoolDatasetIdIdDelete Method for PoolDatasetIdIdDelete
 * Delete dataset/zvol `id`.

`recursive` will also delete/destroy all children datasets.
`force` will force delete busy datasets.


 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdDeleteRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdDelete(ctx _context.Context, id string) ApiPoolDatasetIdIdDeleteRequest {
	return ApiPoolDatasetIdIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdDeleteExecute(r ApiPoolDatasetIdIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetDelete1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdGetRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id []interface{}
	limit *int32
	offset *int32
	count *bool
	sort *string
}

func (r ApiPoolDatasetIdIdGetRequest) Limit(limit int32) ApiPoolDatasetIdIdGetRequest {
	r.limit = &limit
	return r
}
func (r ApiPoolDatasetIdIdGetRequest) Offset(offset int32) ApiPoolDatasetIdIdGetRequest {
	r.offset = &offset
	return r
}
func (r ApiPoolDatasetIdIdGetRequest) Count(count bool) ApiPoolDatasetIdIdGetRequest {
	r.count = &count
	return r
}
func (r ApiPoolDatasetIdIdGetRequest) Sort(sort string) ApiPoolDatasetIdIdGetRequest {
	r.sort = &sort
	return r
}

func (r ApiPoolDatasetIdIdGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdGetExecute(r)
}

/*
 * PoolDatasetIdIdGet Method for PoolDatasetIdIdGet
 * Query Pool Datasets with `query-filters` and `query-options`.

We provide two ways to retrieve datasets. The first is a flat structure (default), where
all datasets in the system are returned as separate objects which contain all data
there is for their children. This retrieval type is slightly slower because of duplicates in each object.
The second type is hierarchical, where only top level datasets are returned in the list. They contain all the
children in the `children` key. This retrieval type is slightly faster.
These options are controlled by the `query-options.extra.flat` attribute (default true).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdGetRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdGet(ctx _context.Context, id []interface{}) ApiPoolDatasetIdIdGetRequest {
	return ApiPoolDatasetIdIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdGetExecute(r ApiPoolDatasetIdIdGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdGetQuotaPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	poolDatasetGetQuota *PoolDatasetGetQuota
}

func (r ApiPoolDatasetIdIdGetQuotaPostRequest) PoolDatasetGetQuota(poolDatasetGetQuota PoolDatasetGetQuota) ApiPoolDatasetIdIdGetQuotaPostRequest {
	r.poolDatasetGetQuota = &poolDatasetGetQuota
	return r
}

func (r ApiPoolDatasetIdIdGetQuotaPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdGetQuotaPostExecute(r)
}

/*
 * PoolDatasetIdIdGetQuotaPost Method for PoolDatasetIdIdGetQuotaPost
 * Return a list of the specified `quota_type` of  quotas on the ZFS dataset `ds`.
Support `query-filters` and `query-options`. used_bytes and used_percentage
may not instantly update as space is used.

When quota_type is not DATASET, each quota entry has these fields:

`id` - the uid or gid to which the quota applies.

`name` - the user or group name to which the quota applies. Value is
null if the id in the quota cannot be resolved to a user or group. This
indicates that the user or group does not exist on the server.

`quota` - the quota size in bytes.

`used_bytes` - the amount of bytes the user has written to the dataset.
A value of zero means unlimited.

`used_percentage` - the percentage of the user or group quota consumed.

`obj_quota` - the number of objects that may be owned by `id`.
A value of zero means unlimited.

'obj_used` - the nubmer of objects currently owned by `id`.

`obj_used_percent` - the percentage of the `obj_quota` currently used.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdGetQuotaPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdGetQuotaPost(ctx _context.Context, id string) ApiPoolDatasetIdIdGetQuotaPostRequest {
	return ApiPoolDatasetIdIdGetQuotaPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdGetQuotaPostExecute(r ApiPoolDatasetIdIdGetQuotaPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdGetQuotaPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/get_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetGetQuota
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdPermissionPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	poolDatasetPermission1 *PoolDatasetPermission1
}

func (r ApiPoolDatasetIdIdPermissionPostRequest) PoolDatasetPermission1(poolDatasetPermission1 PoolDatasetPermission1) ApiPoolDatasetIdIdPermissionPostRequest {
	r.poolDatasetPermission1 = &poolDatasetPermission1
	return r
}

func (r ApiPoolDatasetIdIdPermissionPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdPermissionPostExecute(r)
}

/*
 * PoolDatasetIdIdPermissionPost Method for PoolDatasetIdIdPermissionPost
 * Set permissions for a dataset `id`. Permissions may be specified as
either a posix `mode` or an nfsv4 `acl`. Setting mode will fail if the
dataset has an existing nfsv4 acl. In this case, the option `stripacl`
must be set to `True`.


 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdPermissionPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdPermissionPost(ctx _context.Context, id string) ApiPoolDatasetIdIdPermissionPostRequest {
	return ApiPoolDatasetIdIdPermissionPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdPermissionPostExecute(r ApiPoolDatasetIdIdPermissionPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdPermissionPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/permission"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetPermission1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdProcessesPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	body *map[string]interface{}
}

func (r ApiPoolDatasetIdIdProcessesPostRequest) Body(body map[string]interface{}) ApiPoolDatasetIdIdProcessesPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetIdIdProcessesPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdProcessesPostExecute(r)
}

/*
 * PoolDatasetIdIdProcessesPost Method for PoolDatasetIdIdProcessesPost
 * Return a list of processes using this dataset.

Example return value:

[
  {
    "pid": 2520,
    "name": "smbd",
    "service": "cifs"
  },
  {
    "pid": 97778,
    "name": "minio",
    "cmdline": "/usr/local/bin/minio -C /usr/local/etc/minio server --address=0.0.0.0:9000 --quiet /mnt/tank/wk"
  }
]
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdProcessesPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdProcessesPost(ctx _context.Context, id string) ApiPoolDatasetIdIdProcessesPostRequest {
	return ApiPoolDatasetIdIdProcessesPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdProcessesPostExecute(r ApiPoolDatasetIdIdProcessesPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdProcessesPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/processes"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdPromotePostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	body *map[string]interface{}
}

func (r ApiPoolDatasetIdIdPromotePostRequest) Body(body map[string]interface{}) ApiPoolDatasetIdIdPromotePostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetIdIdPromotePostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdPromotePostExecute(r)
}

/*
 * PoolDatasetIdIdPromotePost Method for PoolDatasetIdIdPromotePost
 * Promote the cloned dataset `id`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdPromotePostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdPromotePost(ctx _context.Context, id string) ApiPoolDatasetIdIdPromotePostRequest {
	return ApiPoolDatasetIdIdPromotePostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdPromotePostExecute(r ApiPoolDatasetIdIdPromotePostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdPromotePost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/promote"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdPutRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	poolDatasetUpdate1 *PoolDatasetUpdate1
}

func (r ApiPoolDatasetIdIdPutRequest) PoolDatasetUpdate1(poolDatasetUpdate1 PoolDatasetUpdate1) ApiPoolDatasetIdIdPutRequest {
	r.poolDatasetUpdate1 = &poolDatasetUpdate1
	return r
}

func (r ApiPoolDatasetIdIdPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdPutExecute(r)
}

/*
 * PoolDatasetIdIdPut Method for PoolDatasetIdIdPut
 * Updates a dataset/zvol `id`.


 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdPutRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdPut(ctx _context.Context, id string) ApiPoolDatasetIdIdPutRequest {
	return ApiPoolDatasetIdIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdPutExecute(r ApiPoolDatasetIdIdPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetUpdate1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetIdIdSetQuotaPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	id string
	requestBody *[]map[string]interface{}
}

func (r ApiPoolDatasetIdIdSetQuotaPostRequest) RequestBody(requestBody []map[string]interface{}) ApiPoolDatasetIdIdSetQuotaPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiPoolDatasetIdIdSetQuotaPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetIdIdSetQuotaPostExecute(r)
}

/*
 * PoolDatasetIdIdSetQuotaPost Method for PoolDatasetIdIdSetQuotaPost
 * There are three over-arching types of quotas for ZFS datasets.
1) dataset quotas and refquotas. If a DATASET quota type is specified in
this API call, then the API acts as a wrapper for `pool.dataset.update`.

2) User and group quotas. These limit the amount of disk space consumed
by files that are owned by the specified users or groups. If the respective
"object quota" type is specfied, then the quota limits the number of objects
that may be owned by the specified user or group.

3) Project quotas. These limit the amount of disk space consumed by files
that are owned by the specified project. Project quotas are not yet implemended.

This API allows users to set multiple quotas simultaneously by submitting a
list of quotas. The list may contain all supported quota types.

`ds` the name of the target ZFS dataset.

`quotas` specifies a list of `quota_entry` entries to apply to dataset.

`quota_entry` entries have these required parameters:

`quota_type`: specifies the type of quota to apply to the dataset. Possible
values are USER, USEROBJ, GROUP, GROUPOBJ, and DATASET. USEROBJ and GROUPOBJ
quotas limit the number of objects consumed by the specified user or group.

`id`: the uid, gid, or name to which the quota applies. If quota_type is
'DATASET', then `id` must be either `QUOTA` or `REFQUOTA`.

`quota_value`: the quota size in bytes. Setting a value of `0` removes
the user or group quota.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiPoolDatasetIdIdSetQuotaPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdSetQuotaPost(ctx _context.Context, id string) ApiPoolDatasetIdIdSetQuotaPostRequest {
	return ApiPoolDatasetIdIdSetQuotaPostRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetIdIdSetQuotaPostExecute(r ApiPoolDatasetIdIdSetQuotaPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetIdIdSetQuotaPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/id/{id}/set_quota"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	body *string
}

func (r ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest) Body(body string) ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetInheritParentEncryptionPropertiesPostExecute(r)
}

/*
 * PoolDatasetInheritParentEncryptionPropertiesPost Method for PoolDatasetInheritParentEncryptionPropertiesPost
 * Allows inheriting parent's encryption root discarding its current encryption settings. This
can only be done where `id` has an encrypted parent and `id` itself is an encryption root.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetInheritParentEncryptionPropertiesPost(ctx _context.Context) ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest {
	return ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetInheritParentEncryptionPropertiesPostExecute(r ApiPoolDatasetInheritParentEncryptionPropertiesPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetInheritParentEncryptionPropertiesPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/inherit_parent_encryption_properties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetLockPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	poolDatasetLock *PoolDatasetLock
}

func (r ApiPoolDatasetLockPostRequest) PoolDatasetLock(poolDatasetLock PoolDatasetLock) ApiPoolDatasetLockPostRequest {
	r.poolDatasetLock = &poolDatasetLock
	return r
}

func (r ApiPoolDatasetLockPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetLockPostExecute(r)
}

/*
 * PoolDatasetLockPost Method for PoolDatasetLockPost
 * Locks `id` dataset. It will unmount the dataset and its children before locking.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetLockPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetLockPost(ctx _context.Context) ApiPoolDatasetLockPostRequest {
	return ApiPoolDatasetLockPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetLockPostExecute(r ApiPoolDatasetLockPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetLockPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/lock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetLock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	poolDatasetCreate0 *PoolDatasetCreate0
}

func (r ApiPoolDatasetPostRequest) PoolDatasetCreate0(poolDatasetCreate0 PoolDatasetCreate0) ApiPoolDatasetPostRequest {
	r.poolDatasetCreate0 = &poolDatasetCreate0
	return r
}

func (r ApiPoolDatasetPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetPostExecute(r)
}

/*
 * PoolDatasetPost Method for PoolDatasetPost
 * Creates a dataset/zvol.

`volsize` is required for type=VOLUME and is supposed to be a multiple of the block size.
`sparse` and `volblocksize` are only used for type=VOLUME.

`encryption` when enabled will create an ZFS encrypted root dataset for `name` pool.
There are 2 cases where ZFS encryption is not allowed for a dataset:
1) Pool in question is GELI encrypted.
2) If the parent dataset is encrypted with a passphrase and `name` is being created
   with a key for encrypting the dataset.

`encryption_options` specifies configuration for encryption of dataset for `name` pool.
`encryption_options.passphrase` must be specified if encryption for dataset is desired with a passphrase
as a key.
Otherwise a hex encoded key can be specified by providing `encryption_options.key`.
`encryption_options.generate_key` when enabled automatically generates the key to be used
for dataset encryption.

It should be noted that keys are stored by the system for automatic locking/unlocking
on import/export of encrypted datasets. If that is not desired, dataset should be created
with a passphrase as a key.


 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetPost(ctx _context.Context) ApiPoolDatasetPostRequest {
	return ApiPoolDatasetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetPostExecute(r ApiPoolDatasetPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetRecommendedZvolBlocksizePostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	body *string
}

func (r ApiPoolDatasetRecommendedZvolBlocksizePostRequest) Body(body string) ApiPoolDatasetRecommendedZvolBlocksizePostRequest {
	r.body = &body
	return r
}

func (r ApiPoolDatasetRecommendedZvolBlocksizePostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetRecommendedZvolBlocksizePostExecute(r)
}

/*
 * PoolDatasetRecommendedZvolBlocksizePost Method for PoolDatasetRecommendedZvolBlocksizePost
 * Helper method to get recommended size for a new zvol (dataset of type VOLUME).


 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetRecommendedZvolBlocksizePostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetRecommendedZvolBlocksizePost(ctx _context.Context) ApiPoolDatasetRecommendedZvolBlocksizePostRequest {
	return ApiPoolDatasetRecommendedZvolBlocksizePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetRecommendedZvolBlocksizePostExecute(r ApiPoolDatasetRecommendedZvolBlocksizePostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetRecommendedZvolBlocksizePost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/recommended_zvol_blocksize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPoolDatasetUnlockPostRequest struct {
	ctx _context.Context
	ApiService *PoolDatasetApiService
	poolDatasetUnlock *PoolDatasetUnlock
}

func (r ApiPoolDatasetUnlockPostRequest) PoolDatasetUnlock(poolDatasetUnlock PoolDatasetUnlock) ApiPoolDatasetUnlockPostRequest {
	r.poolDatasetUnlock = &poolDatasetUnlock
	return r
}

func (r ApiPoolDatasetUnlockPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.PoolDatasetUnlockPostExecute(r)
}

/*
 * PoolDatasetUnlockPost Method for PoolDatasetUnlockPost
 * Unlock `id` dataset.

If `id` dataset is not encrypted an exception will be raised. There is one exception:
when `id` is a root dataset and `unlock_options.recursive` is specified, encryption
validation will not be performed for `id`. This allow unlocking encrypted children the `id` pool.

For datasets which are encrypted with a passphrase, include the passphrase with
`unlock_options.datasets`.

Uploading a json file which contains encrypted dataset keys can be specified with
`unlock_options.key_file`. The format is similar to that used for exporting encrypted dataset keys.

A file can be uploaded to this end point. This end point is special, please refer to Jobs section in Websocket API documentation for details.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiPoolDatasetUnlockPostRequest
 */
func (a *PoolDatasetApiService) PoolDatasetUnlockPost(ctx _context.Context) ApiPoolDatasetUnlockPostRequest {
	return ApiPoolDatasetUnlockPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *PoolDatasetApiService) PoolDatasetUnlockPostExecute(r ApiPoolDatasetUnlockPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoolDatasetApiService.PoolDatasetUnlockPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pool/dataset/unlock"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.poolDatasetUnlock
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
